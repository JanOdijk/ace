import csv
import sys
import os
# import xml.etree.ElementTree as ET
from lxml import etree as ET
# from xml.etree.ElementTree import Element, ElementTree
# from xml.etree.ElementTree import parse
# from xml.etree.ElementTree import iter
from collections import defaultdict
import xlsxwriter
from optparse import OptionParser
# import lassy_stats as treebankstats
import cgnpluslassystats as treebankstats
import children
from anncor import getsentence
from sastadev.treebankfunctions import getyield, getmeta, getattval, bareindexnode, terminal
import cleanCHILDESMD
import read_errors
import configparser
import dcoi_postags
import datetime
import filelock
import re
from chatundo import chatundo, cleanspaces
from sastadev.treebankfunctions import allcats, allrels, allpts
from dcoicloseditems import closeditemdict, postagTheta

# import pwd


program_name = sys.argv[0]
baseversion = "0"
subversion = "16"
version = baseversion + "." + subversion
# print(program_name, version, file=sys.stderr)

exactlynow = datetime.datetime.now()
now = exactlynow.replace(microsecond=0).isoformat()
barenow = re.sub('[\-:]', '', now)

credits = "generated by {} version {} on {} ".format(program_name, version, now)

spacedpuncpattern = r'\s+([!?.])'
spacedpuncre = re.compile(spacedpuncpattern)

message = "Message"
error = "Error"
likely_error = "Likely Error"
warning = "Warning"
sererror = "Serious Error"
level = "level"
relcatsep = '/'
testfile = 'checktestfile.xml'
mysep = "\t"
myquotechar = '"'
space = ' '
fl_extension = '.fl'

puncs = '.!?\'"'

sererrlevel = 10000
errlevel = 1000
likely_errlevel = 500
warnlevel = 100
messagelevel = 10

errors = defaultdict(dict)
errors[1][message] = "occurs more than once"
errors[1][level] = errlevel

errors[2][message] = "must occur together with"
errors[2][level] = errlevel

errors[3][message] = "must occur together with one of"
errors[3][level] = errlevel

errors[4][message] = "illegal child of"
errors[4][level] = likely_errlevel

errors[5][message] = "unlikely child of"
errors[5][level] = warnlevel

errors[6][message] = "lemma must be one of"
errors[6][level] = errlevel

errors[7][message] = "does not combine with"
errors[7][level] = likely_errlevel

errors[9][message] = "unusual combination with"
errors[9][level] = warnlevel

errors[10][message] = "illegal child relation of"
errors[10][level] = likely_errlevel

errors[11][message] = "unusual child relation of"
errors[11][level] = warnlevel

errors[12][message] = "illegal child rel/cat of"
errors[12][level] = likely_errlevel

errors[13][message] = "unusual child rel/cat of"
errors[13][level] = warnlevel

errors[14][message] = "nonterminal node must have at least 2 children"
errors[14][level] = errlevel

errors[15][message] = "pt/pos/index node cannot have children"
errors[15][level] = errlevel

errors[16][message] = "found, but node must have the children"
errors[16][level] = errlevel

errors[17][message] = "node requires feature on the head"
errors[17][level] = errlevel

errors[18][message] = "sv1 requires an initial head. Consider smain instead"
errors[18][level] = errlevel

errors[19][message] = "smain has an initial head. Consider sv1 instead"
errors[19][level] = errlevel

errors[20][message] = "svp can occur twice only for er...uit"
errors[20][level] = errlevel

errors[21][message] = "has empty string as value for cat, pos or pt"
errors[21][level] = errlevel

errors[22][message] = "has no value for cat"
errors[22][level] = sererrlevel

errors[23][message] = "has no value for pos"
errors[23][level] = sererrlevel

errors[24][message] = "has no value for pt"
errors[24][level] = sererrlevel

errors[25][message] = "has no value for rel"
errors[25][level] = sererrlevel

errors[26][message] = "has no value for wordno (end)"
errors[26][level] = sererrlevel

errors[27][message] = "has no value for postag"
errors[27][level] = sererrlevel

errors[28][message] = "terminal node cannot have cat"
errors[28][level] = sererrlevel

errors[29][message] = "nonterminal node cannot have postag"
errors[29][level] = sererrlevel

errors[30][message] = "nonterminal node cannot have pos"
errors[30][level] = sererrlevel

errors[31][message] = "node cannot have both postag and cat"
errors[31][level] = sererrlevel

errors[32][message] = "has no antecedent"
errors[32][level] = sererrlevel

errors[33][message] = "illegal postag"
errors[33][level] = errlevel

errors[34][message] = "is an illegal son of"
errors[34][level] = errlevel

errors[35][message] = "has no begin attribute"
errors[35][level] = sererrlevel

errors[36][message] = "end minus begin is not equal to 1"
errors[36][level] = sererrlevel

errors[37][message] = "has no pt attribute"
errors[37][level] = sererrlevel

errors[38][message] = "uses a duplicate wordno value"
errors[38][level] = sererrlevel

errors[39][message] = "Parse Error: No well-formed tree found"
errors[39][level] = sererrlevel

errors[40][message] = "File not a Unicode file"
errors[40][level] = sererrlevel

errors[41][message] = "File successfully decoded as a Windows-1252 encoded file"
errors[41][level] = messagelevel

errors[42][message] = "Decoding error: not a Windows-1252 encoded file"
errors[42][level] = sererrlevel

errors[43][message] = "File not Found"
errors[43][level] = errlevel

errors[44][message] = "Sentence and yield mismatch"
errors[44][level] = sererrlevel

errors[45][message] = 'Sentence and cleaned (revised) utterance mismatch'
errors[45][level] = sererrlevel

errors[46][message] = 'Whitespace mismatch sentence and cleaned (revised) utterance'
errors[46][level] = messagelevel

errors[47][message] = 'word ends in punctuation symbol'
errors[47][level] = errlevel

errors[48][message] = 'Sentence and cleaned (revised) utterance match only under repkeep=False'
errors[48][level] = messagelevel

errors[49][message] = 'Whitespace mismatch sentence and cleaned (revised) utterance (repkeep=False)'
errors[49][level] = messagelevel

errors[50][message] = 'Deannotated original utterance and current utterance mismatch'
errors[50][level] = sererrlevel

errors[51][message] = 'Illegal relation'
errors[51][level] = errlevel

errors[52][message] = 'Illegal cat'
errors[52][level] = errlevel

errors[53][message] = 'Illegal pt'
errors[53][level] = errlevel

errors[54][message] = 'Incorrect postag'
errors[54][level] = errlevel

errors[55][message] = 'Unlikely postag (or unlikely lemma)'
errors[55][level] = warnlevel

errors[56][message] = 'Unlikely combination or rel and positie'
errors[56][level] = errlevel

errors[57][message] = '"dus" moet pt=bw hebben'
errors[57][level] = errlevel

# hdf|hd|cmp|sup|su|obj1|pobj1|obj2|se|pc|vc|svp|predc|ld|me|
#                 predm|obcomp|mod|body|det|app|whd|rhd|cnj|crd|nucl|sat|tag|
#                 dp|top|mwp|dlink|--


# singlerels derived from get-stats.py toegepast op LASSY-Small
singlerels = ['body', 'cmp', 'dlink', 'hd', 'hdf', 'ld', 'me', 'nucl', 'obcomp', 'obj1', 'obj2', 'ld', 'pc',
              'pobj1', 'predc', 'rhd', 'sat', 'se', 'su', 'sup', 'vc', 'whd']
complrels = ['ld', 'me', 'obj1', 'obj2', 'pc', 'pobj1', 'predc', 'se', 'su', 'sup', 'svp', 'vc']

implies = {'rhd': 'body', 'whd': 'body', 'crd': 'cnj', 'cmp': 'body'}
zijncomplements = ['predc', 'vc', 'ld', 'su', 'pc']
notzijncomplements = [el for el in complrels if el not in zijncomplements]
mcatcatTheta = treebankstats.mcatcatTheta
relposcatTheta = treebankstats.relposcatTheta
mcatrelTheta = treebankstats.mcatrelTheta
mcatrelcatTheta = treebankstats.mcatrelcatTheta


class CheckParameters:
    def __init__(self, filename, mothercat, noderelcat, arg1, arg2, remarks, error_annotations):
        self.filename = filename
        self.mothercat = mothercat
        self.noderelcat = noderelcat
        self.arg1 = arg1
        self.arg2 = arg2
        self.remarks = remarks
        self.error_annotations = error_annotations


class FileLists:
    def __init__(self):
        self.allerrors = []
        self.seriouserrors = []
        self.errors = []
        self.likely_errors = []
        self.warnings = []

    def assignname(self, name):
        self.allerrors = [name] + self.allerrors
        self.seriouserrors = [name] + self.seriouserrors
        self.errors = [name] + self.errors
        self.likely_errors = [name] + self.likely_errors
        self.warnings = [name] + self.warnings

    def update(self, apath, theerrlevel):
        if theerrlevel == sererrlevel:
            if self.seriouserrors[-1] != apath:
                self.seriouserrors.append(apath)
        elif theerrlevel == errlevel:
            if self.errors[-1] != apath:
                self.errors.append(apath)
        elif theerrlevel == likely_errlevel:
            if self.likely_errors[-1] != apath:
                self.likely_errors.append(apath)
        elif theerrlevel == warnlevel:
            if self.warnings[-1] != apath:
                self.warnings.append(apath)
        elif theerrlevel == messagelevel:
            pass
        else:
            print('Unknown error level: {}'.format(theerrlevel), file=sys.stderr)
        if self.allerrors[-1:] != apath:
            self.allerrors.append(apath)

    def print(self):
        fl_print(self.allerrors, 'allerrors')
        fl_print(self.seriouserrors, 'seriouserrors')
        fl_print(self.errors, 'errors')
        fl_print(self.likely_errors, 'likely_errors')
        fl_print(self.warnings, 'warnings')


def endswithpunc(instr):
    if len(instr) <= 1:
        return False
    elif instr[-1] in puncs:
        return True
    else:
        return False


def containspunc(instr):
    if len(instr) == 1:
        return False
    else:
        for ch in puncs:
            if ch in instr:
                return True
    return False


def get_files(filelistname):
    result = []
    filelist = open(filelistname, 'r', encoding='utf8')
    linectr = 0
    for line in filelist:
        if linectr != 0:
            result.append(line[:-1])
        linectr += 1
    return result


def fl_print(fl, errname):
    if fl is not None and fl != [] and len(fl) != 1:
        thename = fl[0] + '_' + errname
        fl[0] = thename
        thefilename = thename + fl_extension
        with open(thefilename, 'w', encoding='utf8') as thefile:
            for el in fl:
                print(el, file=thefile)


def printq(str):
    sys.stderr.write(str)
    sys.stderr.flush()


def conjunctissmain(node, mother, indexednodes):
    # print("node=", str(getPosCat(node)), file=sys.stderr)
    # print("mother=", str(getPosCat(mother)), file=sys.stderr)
    smaincnjfound = False
    if mother is None:
        return (smaincnjfound)
    else:
        for el in mother:
            # print("el=",str(getPosCat(el)), file=sys.stderr)
            if el != node and el.attrib['rel'] == 'cnj' and not smaincnjfound:
                thedescendants = get_descendantnodes(el, indexednodes)
                # print(thedescendants, file=sys.stderr)
                # print(input("Continue?"), file=sys.stderr)
                sorteddescendants = sorted(thedescendants, key=lambda node: int(node.attrib['end']))
                if not ((sorteddescendants[0].attrib['rel'] == 'hd' and getPosCat(sorteddescendants[0]) == 'ww')):
                    smaincnjfound = True
                    # print("smaincnjfound=", smaincnjfound, file=sys.stderr)
        # print(input("Continue?"))
        return (smaincnjfound)


def setpar(optionpar, configpar):
    if optionpar is None or optionpar == "":
        result = configpar
    else:
        result = optionpar
    return (result)


def levelstr(level):
    if level >= sererrlevel:
        result = sererror
    elif level >= errlevel:
        result = error
    elif level >= likely_errlevel:
        result = likely_error
    elif level >= warnlevel:
        result = warning
    else:
        result = "message"
    return (result)


def iseruit(childs):
    if len(childs) != 2:
        result = False
    elif childs[0].attrib['word'] == 'er' and childs[1].attrib['word'] == 'uit':
        result = True
    elif childs[1].attrib['word'] == 'er' and childs[0].attrib['word'] == 'uit':
        result = True
    else:
        result = False
    return (result)


#         row=["","","Error", fullname,mothercat, noderelcat, errno, arg1,message, arg2, remarks]

def error_row(errno, cp):
    error_annotations = cp.error_annotations
    # for key in error_annotations:
    #    if key[0] == 'laura47_0196.xml':
    #        l47_0186key = key
    mothercat = cp.mothercat
    noderelcat = cp.noderelcat
    arg1 = cp.arg1
    arg2 = cp.arg2
    remarks = cp.remarks
    fullname = cp.filename
    pathname = os.path.dirname(fullname)
    filename = os.path.basename(fullname)
    themessage = errors[errno][message]
    thekey = (filename, mothercat, noderelcat, str(errno), arg1, arg2)
    if thekey in error_annotations:
        (user1, user2, annotator) = error_annotations[thekey]
    else:
        (user1, user2, annotator) = ("", "", username)
    filelink = 'file:///' + fullname
    row = [user1, user2, levelstr(errors[errno][level]), filename, mothercat, noderelcat, errno, arg1, themessage, arg2,
           remarks, pathname, annotator]
    return (row)


def printerror(row, tsv, ignoreannotatederrors=True):
    global rowcounter, FL, errors
    if tsv:
        mywriter.writerow(row)
    else:
        rowcounter += 1
        worksheet.write_row(rowcounter, 0, row)
        # theabspath=makeabs(row[3])
    theabspath = os.path.join(row[11], row[3])
    # print(theabspath, file=flfile)
    errno = int(row[6])
    errlevel = errors[errno][level]
    if ignoreannotatederrors:
        if row[0] == '':
            FL.update(theabspath, errlevel)
    else:
        FL.update(theabspath, errlevel)


def getAttrib(node):
    result = None
    if 'pt' in node.attrib:
        result = node.attrib
    #  elif 'cat' in node.attrib and node.attrib['cat'] in mwus:
    #     result = getMWUattrib(node)
    elif 'cat' in node.attrib:
        result = node.attrib
    elif 'index' in node.attrib:
        result = indexednodes[node.attrib['index']].attrib
        result['rel'] = node.attrib['rel']
    elif 'pos' in node.attrib:  # there are cases with pos but not pt
        result = node.attrib
    elif len(node) >= 1:
        therel = node.attrib['rel'] if 'rel' in node.attrib else ''
        result = {'cat': '', 'rel': therel}
    else:
        therel = node.attrib['rel'] if 'rel' in node.attrib else ''
        result = {'pt': '', 'pos': '', 'rel': therel}
    return (result)


def getPosCat(node):
    if node is not None:
        att = getAttrib(node)
        if 'pt' in att:
            result = att['pt']
        elif 'cat' in att:
            result = att['cat']
        elif 'pos' in att:
            result = att['pos']
        else:
            result = "unknown poscat"
    else:
        result = "None node"
    return (result)


def getExt(file):
    (base, ext) = os.path.splitext(file)
    return (ext)


def nonempty(node):
    result = 'pt' in node.attrib or 'pos' in node.attrib or 'cat' in node.attrib
    return (result)


def get_descendantnodes(node, indexednodes):
    result = []
    for w in node.iter():
        if 'pt' in w.attrib or 'pos' in w.attrib:
            result.append(w)
    # this wrong, will cause errors for all sv1s
    #    elif 'cat' not in w.attrib and 'index' in w.attrib:
    #      antchilds=get_descendantnodes(indexednodes[w.attrib['index']], indexednodes)
    #      for ach in antchilds:
    #         result.append(ach)
    # print(w.attrib['word'], w.attrib['end'],file=sys.stderr)
    # print(input('Continue?'), file=sys.stderr)
    return (result)


def bimplies(a, b):
    return (not (a) or b)


def lexical(node):
    result = 'pt' in node.attrib or 'pos' in node.attrib
    return result


def get_node_props(node):
    if node is None:
        result = ("None", "None", "None")
    else:
        rel = node.attrib['rel'] if 'rel' in node.attrib else "??"
        if 'postag' in node.attrib:
            postag = node.attrib['postag']
        elif 'pos' in node.attrib:
            postag = node.attrib['pos']
        elif 'pt' in node.attrib:
            postag = node.attrib['pt']
        elif 'cat' in node.attrib:
            postag = node.attrib['cat']
        else:
            postag = "??"
        theindex = node.attrib['index'] if 'index' in node.attrib else ""
        result = (rel, postag, theindex)
    return (result)


def props2str(props):
    (noderel, nodecat, nodeind) = props
    result = noderel + "/" + nodecat + (":" + nodeind if nodeind != "" else "")
    return (result)


def clean(str):
    if str is None:
        result = None
    else:
        result = space.join(str.split())
    return result


def fulltreechecks(stree, fullname, error_annotations):
    # check whether yield of stree and sentence are identical
    sent = getsentence(stree)
    yield1 = getyield(stree)
    yield1str = space.join(yield1)
    cleansent = clean(sent)
    sentandyieldok = cleansent == yield1str
    # print('cleansent=<{}>'.format(cleansent))
    # print('yield1str=<{}>'.format(yield1str))
    mothercat = getattval(stree, 'cat')
    nodecat = mothercat
    noderel = getattval(stree, 'rel')
    noderelcat = '{}/{}'.format(noderel, nodecat)
    remarks = ''
    if not sentandyieldok:
        errno = 44
        cp = CheckParameters(filename, mothercat, noderelcat, cleansent, yield1str, remarks, error_annotations)
        row = error_row(errno, cp)
        printerror(row, options.tsv)

    # check whether revisedutt, if available, otherwise originalutt equals sentence
    revisedutt = getmeta(stree, 'revisedutt', treebank=False)
    origutt = getmeta(stree, 'origutt', treebank=False)
    if not (revisedutt is None and origutt is None):
        reviseduttfound = revisedutt is not None
        theutt = revisedutt if reviseduttfound else origutt
        cleanutt = cleanCHILDESMD.cleantext(theutt, repkeep=True)
        cleanuttnorepkeep = cleanCHILDESMD.cleantext(theutt, repkeep=False)

        cleansentandcleanuttok = cleansent == cleanutt
        cleansentandcleanuttnorepkeepok = cleansent == cleanuttnorepkeep

        # if not identical, check replacing '\s+([.?!])' by '\1' in both

        unspacedsent = spacedpuncre.sub(r'\1', cleansent)
        unspacedcleanutt = spacedpuncre.sub(r'\1', cleanutt)

        unspacedsentanduttok = unspacedsent == unspacedcleanutt

        unspacedcleanuttnorepkeep = spacedpuncre.sub(r'\1', cleanuttnorepkeep)

        unspacedsentanduttnorepkeepok = unspacedsent == unspacedcleanuttnorepkeep

        # print('origutt=<{}>'.format(origutt))
        # if reviseduttfound:
        #    print('revisedutt=<{}>'.format(revisedutt))
        # print('unspacedsent=<{}>'.format(unspacedsent))
        # print('unspacedcleanutt=<{}>'.format(unspacedcleanutt))
        remarksprefix = 'revisedutt=' if reviseduttfound else 'origutt='
        remarks = remarksprefix + theutt
        if not cleansentandcleanuttok and not cleansentandcleanuttnorepkeepok and unspacedsentanduttok:
            errno = 46
            cp = CheckParameters(filename, mothercat, noderelcat, cleansent, cleanutt, remarks, error_annotations)
            row = error_row(errno, cp)
            printerror(row, options.tsv)
        elif not cleansentandcleanuttok and not cleansentandcleanuttnorepkeepok and unspacedsentanduttnorepkeepok:
            errno = 49
            cp = CheckParameters(filename, mothercat, noderelcat, cleansent, cleanuttnorepkeep, remarks,
                                 error_annotations)
            row = error_row(errno, cp)
            printerror(row, options.tsv)
        elif not cleansentandcleanuttok and unspacedsentanduttok:
            errno = 46
            cp = CheckParameters(filename, mothercat, noderelcat, cleansent, cleanutt, remarks, error_annotations)
            row = error_row(errno, cp)
            printerror(row, options.tsv)
        elif not cleansentandcleanuttok and cleansentandcleanuttnorepkeepok:
            errno = 48
            cp = CheckParameters(filename, mothercat, noderelcat, cleansent, cleanutt, remarks, error_annotations)
            row = error_row(errno, cp)
            printerror(row, options.tsv)
        elif not cleansentandcleanuttok and not unspacedsentanduttok:
            errno = 45
            cp = CheckParameters(filename, mothercat, noderelcat, cleansent, cleanutt, remarks, error_annotations)
            row = error_row(errno, cp)
            printerror(row, options.tsv)

    if revisedutt is not None and origutt is not None:
        undoneorigutt = chatundo(origutt)
        undonerevisedutt = chatundo(revisedutt)
        cleanundoneorigutt = cleanspaces(undoneorigutt)
        cleanundonerevisedutt = cleanspaces(undonerevisedutt)

        if cleanundoneorigutt != cleanundonerevisedutt:
            errno = 50
            remarks = 'origutt={}'.format(origutt)
            cp = CheckParameters(filename, mothercat, noderelcat, cleanundoneorigutt, cleanundonerevisedutt, remarks,
                                 error_annotations)
            row = error_row(errno, cp)
            printerror(row, options.tsv)


def speconverst(node):
    if node is not None:
        result = 'pt' in node.attrib and node.attrib['pt'] == 'spec' and \
                 'spectype' in node.attrib and node.attrib['spectype'] == 'onverst'
    else:
        result = False
    return result


def basicchecks(node, mother, fullname, begins, ends, error_annotations):
    remarks = ""
    mothercat = getPosCat(mother)
    noderelcat = props2str(get_node_props(node))

    basiccheckOK = True
    if not bareindexnode(node):
        if terminal(node) and 'postag' not in node.attrib:
            errno = 27
            basiccheckOK = False
            arg2 = ""
            arg1 = noderelcat
            cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
            row = error_row(errno, cp)
            printerror(row, options.tsv)
        if terminal(node) and 'pos' not in node.attrib:
            errno = 23
            basiccheckOK = False
            arg2 = ""
            arg1 = noderelcat
            cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
            row = error_row(errno, cp)
            printerror(row, options.tsv)
        if not terminal(node) and 'cat' not in node.attrib:
            errno = 22
            basiccheckOK = False
            arg2 = ""
            arg1 = noderelcat
            cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
            row = error_row(errno, cp)
            printerror(row, options.tsv)
        if 'postag' in node.attrib and 'cat' in node.attrib:
            errno = 31
            basiccheckOK = False
            arg2 = ""
            arg1 = noderelcat
            cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
            row = error_row(errno, cp)
            printerror(row, options.tsv)
        if terminal(node) and 'cat' in node.attrib:
            errno = 28
            basiccheckOK = False
            arg2 = ""
            arg1 = noderelcat
            cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
            row = error_row(errno, cp)
            printerror(row, options.tsv)
        if not terminal(node) and 'postag' in node.attrib:
            errno = 29
            basiccheckOK = False
            arg2 = ""
            arg1 = noderelcat
            cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
            row = error_row(errno, cp)
            printerror(row, options.tsv)
        if not terminal(node) and 'pos' in node.attrib:
            errno = 30
            basiccheckOK = False
            arg2 = ""
            arg1 = noderelcat
            cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
            row = error_row(errno, cp)
            printerror(row, options.tsv)
        if lexical(node) and 'end' not in node.attrib:
            errno = 26
            basiccheckOK = False
            arg2 = ""
            arg1 = noderelcat
            cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
            row = error_row(errno, cp)
            printerror(row, options.tsv)
        if lexical(node) and 'begin' not in node.attrib:
            errno = 35
            basiccheckOK = False
            arg2 = ""
            arg1 = noderelcat
            cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
            row = error_row(errno, cp)
            printerror(row, options.tsv)
        if lexical(node) and 'end' in node.attrib and 'begin' in node.attrib and int(node.attrib['end']) - int(
                node.attrib['begin']) != 1:
            errno = 36
            basiccheckOK = False
            arg2 = ""
            arg1 = noderelcat
            cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
            row = error_row(errno, cp)
            printerror(row, options.tsv)
        if lexical(node) and 'pt' not in node.attrib:
            # print('begins={}'.format(begins))
            errno = 37
            basiccheckOK = False
            arg2 = ''
            arg1 = noderelcat
            cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
            row = error_row(errno, cp)
            printerror(row, options.tsv)
        if lexical(node) and 'begin' in node.attrib:
            begins.append(node.attrib['begin'])
        if lexical(node) and 'end' in node.attrib and node.attrib['end'] in ends:
            # print('ends={}'.format(ends))
            errno = 38
            basiccheckOK = False
            arg2 = node.attrib['end']
            arg1 = noderelcat
            cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
            row = error_row(errno, cp)
            printerror(row, options.tsv)

        if lexical(node) and 'end' in node.attrib:
            ends.append(node.attrib['end'])

    if 'rel' not in node.attrib:
        errno = 25
        basiccheckOK = False
        arg2 = ""
        arg1 = noderelcat
        cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
        row = error_row(errno, cp)
        printerror(row, options.tsv)
    for child in (node):
        basiccheckOK = basicchecks(child, node, fullname, begins, ends, error_annotations) and basiccheckOK

    return (basiccheckOK)


def checks(node, mother, fullname, error_annotations):
    global rowcounter
    rels = defaultdict(int)
    relorcatok = True  # needed to avoid error 11 when 4 or 10 has occurred
    relorcatlikely = True  # needed to acoid erro 13 when 5 or 12 has occurred
    rels = {}
    poscat = getPosCat(node)
    mothercat = getPosCat(mother)
    noderel = node.attrib['rel'] if 'rel' in node.attrib else "??"
    noderelcat = relcatsep.join([noderel, poscat])
    remarks = ""
    allchildren = []
    allchildrenrels = []
    for child in node:
        allchildrenrels.append(child.attrib['rel'])
        allchildren.append(child)
    if poscat in ['smain', 'sv1']:
        thedescendants = get_descendantnodes(node, indexednodes)
        sorteddescendants = sorted(thedescendants, key=lambda node: int(node.attrib['end']))

    if poscat == 'smain' and (sorteddescendants[0].attrib['rel'] == 'hd' and getPosCat(sorteddescendants[0]) == 'ww'):
        cjsmcheck = conjunctissmain(node, mother, indexednodes)
        if not cjsmcheck:
            errno = 19
            arg2 = ""
            arg1 = poscat
            cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
            row = error_row(errno, cp)
            printerror(row, options.tsv)
    if poscat == 'sv1' and (not conjunctissmain(node, mother, indexednodes)) and not (
            sorteddescendants[0].attrib['rel'] == 'hd' and sorteddescendants[0].attrib['pt'] == 'ww'):
        errno = 18
        arg2 = ""
        arg1 = poscat
        # print("arg1", arg1, file = sys.stderr)
        cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
        row = error_row(errno, cp)
        printerror(row, options.tsv)
    if poscat == "" and 'index' not in getAttrib(node):
        errno = 21
        arg2 = poscat
        arg1 = noderel
        cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
        row = error_row(errno, cp)
        printerror(row, options.tsv)
    if noderel not in allrels:
        errno = 51
        arg1 = noderel
        arg2 = ''
        cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
        row = error_row(errno, cp)
        printerror(row, options.tsv)
    if 'cat' in node.attrib and node.attrib['cat'] not in allcats:
        errno = 52
        arg1 = node.attrib['cat']
        cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
        row = error_row(errno, cp)
        printerror(row, options.tsv)
    if 'pt' in node.attrib and node.attrib['pt'] not in allpts:
        errno = 53
        arg1 = node.attrib['pt']
        cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
        row = error_row(errno, cp)
        printerror(row, options.tsv)
    if 'pt' in node.attrib:
        pt = getattval(node, 'pt')
        word = getattval(node, 'word')
        wl = word.lower()
        lemma = getattval(node, 'lemma')
        postag = getattval(node, 'postag')
        if wl in closeditemdict and lemma in closeditemdict[wl] and pt in closeditemdict[wl][lemma]:
            if postag not in closeditemdict[wl][lemma][pt]:
                errno = 54
                arg1 = word
                validpostags = [postag for postag in closeditemdict[wl][lemma][
                    pt]]  # if closeditemdict[wl][lemma][pt][postag] >= postagTheta]
                if validpostags == []:
                    validpostags = [postag for postag in closeditemdict[wl][lemma][pt]]
                arg2 = 'postag= {} but expected one of [{}]'.format(postag, ','.join(validpostags))
                cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
                row = error_row(errno, cp)
                printerror(row, options.tsv)
            elif postag in closeditemdict[wl][lemma][pt] and closeditemdict[wl][lemma][pt][postag] < postagTheta:
                errno = 55
                arg1 = '{} / {}'.format(word, lemma)
                validpostags = [postag for postag in closeditemdict[wl][lemma][pt] if
                                closeditemdict[wl][lemma][pt][postag] >= postagTheta]
                arg2 = 'postag={}'.format(
                    postag) if validpostags == [] else 'postag={}; more likely one of [{}]'.format(postag, ','.join(
                    validpostags))
                cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
                row = error_row(errno, cp)
                printerror(row, options.tsv)
    infvrijrels = {'body', 'cnj', 'dp', 'hd', 'mwp', 'nucl', 'sat', 'svp', 'tag', 'vc', '--'}
    notinfnomrels = {'vc'}
    if 'pt' in node.attrib and getattval(node, 'pt') == 'ww' and getattval(node, 'wvorm') == 'inf' and getattval(node,
                                                                                                                 'positie') == 'vrij' and getattval(
            node, 'rel') not in infvrijrels:
        errno = 56
        arg1 = getattval(node, 'word')
        arg2 = 'positie=vrij incompatibel with rel. Expected positie=nom or rel from [{}]'.format(infvrijrels)
        cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
        row = error_row(errno, cp)
        printerror(row, options.tsv)
    if 'pt' in node.attrib and getattval(node, 'pt') == 'ww' and getattval(node, 'wvorm') == 'inf' and getattval(node,
                                                                                                                 'positie') == 'nom' and getattval(
            node, 'rel') in notinfnomrels:
        errno = 56
        arg1 = getattval(node, 'word')
        arg2 = 'positie=nom incompatible with rel. Expected positie=vrij or rel not from [{}]'.format(notinfnomrels)
        cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
        row = error_row(errno, cp)
        printerror(row, options.tsv)
    if mothercat == 'np' and 'pt' in node.attrib and getattval(node, 'pt') == 'ww' and getattval(node,
                                                                                                 'wvorm') == 'inf' and getattval(
            node, 'rel') == 'hd' and getattval(node, 'positie') != 'nom':
        errno = 56
        arg1 = getattval(node, 'word')
        arg2 = 'positie incompatible with np mother. Expected positie=nom'
        cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
        row = error_row(errno, cp)
        printerror(row, options.tsv)
    if getattval(node, 'lemma') == 'dus' and getattval(node, 'pt') != 'bw':
        errno = 57
        arg1 = getattval(node, 'pt')
        arg2 = ''
        cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
        row = error_row(errno, cp)
        printerror(row, options.tsv)

    vrijbodymothercats = {'ti'}
    if 'pt' in node.attrib and getattval(node, 'pt') == 'ww' and getattval(node, 'wvorm') == 'inf' and getattval(node,
                                                                                                                 'body') == 'hd' and getattval(
            node, 'positie') == 'vrij' and mothercat not in vrijbodymothercats:
        errno = 56
        arg1 = getattval(node, 'word')
        arg2 = 'positie incompatible with  mother. Expected mother cat in [{}]'.format(vrijbodymothercats)
        cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
        row = error_row(errno, cp)
        printerror(row, options.tsv)
    nombodymothercats = {'cp'}
    if 'pt' in node.attrib and getattval(node, 'pt') == 'ww' and getattval(node, 'wvorm') == 'inf' and getattval(node,
                                                                                                                 'body') == 'hd' and getattval(
            node, 'positie') == 'nom' and mothercat not in nombodymothercats:
        errno = 56
        arg1 = getattval(node, 'word')
        arg2 = 'positie incompatible with  mother. Expected mother cat in [{}]'.format(nombodymothercats)
        cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
        row = error_row(errno, cp)
        printerror(row, options.tsv)
    if 'cat' in node.attrib and node.attrib['cat'] in children.requireschildfeature:
        (therel, thept, thefeat, thefeatvals) = children.requireschildfeature[node.attrib['cat']]
        # relevantchilds= [ch for ch in allchildren if
        #     ('pt' in ch.attrib and ch.attrib['pt']==thept and ch.attrib['rel']==therel)]
        relevantchilds = []
        for ch in allchildren:
            chatt = getAttrib(ch)
            if 'pt' in chatt and chatt['pt'] == thept and chatt['rel'] == therel:
                relevantchilds.append(ch)
        ok = False if relevantchilds == [] else True
        for ch in relevantchilds:
            chatt = getAttrib(ch)
            if thefeat not in chatt or chatt[thefeat] not in thefeatvals:
                ok = False
            # print(fullname, getPosCat(node), getPosCat(ch),thefeat,  ok, file=sys.stderr)
            # if ok: print(ch.attrib[thefeat], file=sys.stderr)
        # print(input("Continue?"), file=sys.stderr)
        if (not ok):
            errno = 17
            # print("errno", errno, file = sys.stderr)
            arg2 = relcatsep.join([therel, thept]) + ":" + thefeat + " in " + str(thefeatvals)
            arg1 = poscat
            # print("arg1", arg1, file = sys.stderr)
            cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
            row = error_row(errno, cp)
            printerror(row, options.tsv)
    # next one covered by statistics gathered
    #   if 'cat' in node.attrib and node.attrib['cat'] in children.possiblesons:
    #      for achild in allchildren:
    #          chrel= achild.attrib['rel']
    #          if chrel not in children.possiblesons[node.attrib['cat']]:
    #              errno=34
    #              arg1=chrel
    #              arg2= poscat
    #              row=error_row(errno,fullname,mothercat,noderelcat, arg1, arg2, remarks)
    #              printerror(row,options.tsv)
    if 'cat' in node.attrib and node.attrib['cat'] in children.requiredsons:
        for arel in children.requiredsons[node.attrib['cat']]:
            if arel not in allchildrenrels:
                errno = 16
                arg2 = str(children.requiredsons[node.attrib['cat']])
                arg1 = str(allchildrenrels)
                cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
                row = error_row(errno, cp)
                printerror(row, options.tsv)
    if 'word' in node.attrib and endswithpunc(node.attrib['word']):
        errno = 47
        arg2 = node.attrib['word']
        arg1 = noderelcat
        cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
        row = error_row(errno, cp)
        printerror(row, options.tsv)
    if 'cat' in node.attrib and len(node) < 2 and node.attrib['cat'] != 'top':
        errno = 14
        arg2 = ""
        arg1 = noderelcat
        cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
        row = error_row(errno, cp)
        printerror(row, options.tsv)
    elif (('pt' in node.attrib) and (len(node) != 0)) or (('pos' in node.attrib) and (len(node) != 0)) or (
            ('cat' not in node.attrib and 'index' in node.attrib) and (len(node) != 0)):
        errno = 15
        arg2 = ""
        if 'pt' in node.attrib:
            poscat = node.attrib['pt']
        elif 'pos' in node.attrib:
            poscat = node.attrib['pos']
        elif 'index' in node.attrib:
            poscat = "index: " + node.attrib['index']
        arg1 = noderelcat
        cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
        row = error_row(errno, cp)
        printerror(row, options.tsv)
    svpchilds = []
    for child in node:
        if 'postag' in child.attrib:
            if child.attrib['postag'] not in dcoi_postags.legal_DCOI_postags:
                errno = 33
                arg2 = child.attrib['postag']
                arg1 = child.attrib['word'] if 'word' in child.attrib else ""
                cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
                row = error_row(errno, cp)
                printerror(row, options.tsv)

        if 'rel' in child.attrib:
            if child.attrib['rel'] == 'svp':
                svpchilds.append(child)
            key = child.attrib['rel']
            if key in rels:
                rels[key] += 1
            else:
                rels[key] = 1
    if not bimplies(len(svpchilds) == 2, iseruit(svpchilds)):
        errno = 20
        arg1 = 'svp'
        arg2 = ""
        cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
        row = error_row(errno, cp)
        printerror(row, options.tsv)
    for rel in rels:
        if rel in singlerels and rels[rel] > 1:
            errno = 1
            arg1 = rel
            arg2 = ""
            cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
            row = error_row(errno, cp)
            printerror(row, options.tsv)
        if rel in implies:
            if implies[rel] not in rels:
                errno = 2
                arg1 = rel
                arg2 = implies[rel]
                cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
                row = error_row(errno, cp)
                # row=["","","Error", fullname,motherrel, mothercat, errno, arg1,message, arg2, remarks]
                printerror(row, options.tsv)
    # check complements of zijn
    zijnfound = False
    for child in node:
        if 'pt' in child.attrib and 'lemma' in child.attrib and child.attrib[
            'lemma'] == 'zijn' and 'root' in child.attrib and child.attrib['root'] == 'ben' and child.attrib[
            'pt'] == 'ww' and 'rel' in child.attrib and child.attrib['rel'] == 'hd':
            zijnfound = True
    if zijnfound:
        zijnok = False
        predcfound = False
        findpredc = False
        for child in node:
            if child.attrib['rel'] in zijncomplements:
                zijnok = True
            if child.attrib['rel'] in notzijncomplements:
                findpredc = True
            if child.attrib['rel'] == 'predc':
                predcfound = True
        zijnok = zijnok or ((not findpredc) or predcfound)
        if not zijnok:
            errno = 3
            arg1 = 'zijn'
            arg2 = str(zijncomplements)
            cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
            row = error_row(errno, cp)
            # row=["","","Error", fullname,motherrel, mothercat, errno, arg1,message, arg2, remarks]
            printerror(row, options.tsv)
    # mcatcat
    for child in node:
        chposcat = getPosCat(child)
        chatt = getAttrib(child)
        chrel = chatt['rel']
        if (poscat, chposcat) not in treebankstats.mcatcat and not speconverst(node):
            errno = 4
            relorcatok = False
            arg1 = chposcat
            arg2 = poscat
            cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
            row = error_row(errno, cp)
            printerror(row, options.tsv)
        elif treebankstats.mcatcat[poscat, chposcat] < mcatcatTheta and not speconverst(node):
            errno = 5
            relorcatlikely = False
            arg1 = chposcat
            arg2 = poscat
            cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
            row = error_row(errno, cp)
            # row=["","","Warning", fullname,motherrel, mothercat, errno, arg1,message, arg2, remarks]
            printerror(row, options.tsv)
        if (poscat, chrel) not in treebankstats.mcatrel:
            errno = 10
            relorcatok = False
            arg1 = chrel
            arg2 = poscat
            cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
            row = error_row(errno, cp)
            printerror(row, options.tsv)
        elif treebankstats.mcatrel[poscat, chrel] < mcatrelTheta:
            errno = 11
            relorcatlikely = False
            arg1 = chrel
            arg2 = poscat
            cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
            row = error_row(errno, cp)
            printerror(row, options.tsv)
        if (poscat, chrel, chposcat) not in treebankstats.mcatrelcat:
            if relorcatok and not speconverst(node):
                errno = 12
                arg1 = relcatsep.join([chrel, chposcat])
                arg2 = poscat
                cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
                row = error_row(errno, cp)
                printerror(row, options.tsv)
        elif treebankstats.mcatrelcat[poscat, chrel, chposcat] < mcatrelcatTheta:
            if relorcatlikely and not speconverst(node):
                errno = 13
                arg1 = relcatsep.join([chrel, chposcat])
                arg2 = poscat
                cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
                row = error_row(errno, cp)
                printerror(row, options.tsv)
        # pobj1 = het of er
        if chrel == 'pobj1':
            if chatt['lemma'] not in ['het', 'er']:
                errno = 6
                arg1 = chrel
                arg2 = str(['het', 'er'])
                cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
                row = error_row(errno, cp)
                printerror(row, options.tsv)
                if (chrel, chposcat) not in treebankstats.relposcat:
                    errno = 7
                    arg1 = chrel
                    arg2 = chposcat
                    cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
                    row = error_row(errno, cp)
                    printerror(row, options.tsv)
                elif treebankstats.relposcat[(chrel, chposcat)] < relposcatTheta:
                    errno = 9
                    arg1 = chrel
                    arg2 = chposcat
                    cp = CheckParameters(fullname, mothercat, noderelcat, arg1, arg2, remarks, error_annotations)
                    row = error_row(errno, cp)
                    printerror(row, options.tsv)

    # recursive step
    for child in node:
        checks(child, node, fullname, error_annotations)


def makeabs(path):
    if not os.path.isabs(path):
        result = os.path.abspath(path)
    else:
        result = path
    return (result)


def set_default(option, defaultvalue):
    if option is None or option == "":
        result = defaultvalue
    else:
        result = option
    return (result)


# main program

parser = OptionParser()
parser.add_option("-f", "--file", dest="filename", default="",
                  help="Check the given file (default: None)")
parser.add_option("-p", "--path",
                  dest="path",
                  help="path of the files to be checked (default=.)")
parser.add_option("-l", "--filelist", dest="filelist", default="", help='filelist: Check the files in the filelist')
parser.add_option("--tsv", action="store_true", dest="tsv", help="Output in tsv format (default: False)")
parser.add_option("--test", action="store_true", dest="test", help="Check the testfolder (default: False)")
parser.add_option("--outpath", dest="outpath", help="Output path (default=.)")
parser.add_option("--outfile", dest="outfile",
                  help="Filename of the file contain the warnings and errors (default=errors)")
parser.add_option("--permfile", dest="permfile",
                  help="Filename of the permanently stored error annotations (default=permannerrors)")
parser.add_option("--permfilepath", dest="permfilepath",
                  help="Path for the Filename of the permanently stored error annotations (default=temp")
parser.add_option("--ext", dest="ext", help="Extension of the files to be checked (default= .xml)")
parser.add_option("--verbose", dest="verbose", action="store_true", help="show file being processed (default=False)")
parser.add_option("--ini", dest="inifile", help="Configuration file (default=<program_name>.ini)")
parser.add_option("--reportevery", dest="reportevery",
                  help="Progress indication by number of files (default='' -no reporting)")

(options, args) = parser.parse_args()

if options.filelist != "" and options.path != ".":
    print('Only one of path (-p) and filelist (-l) can be specified. Aborting')
    exit(-1)

# read inifile if one is specified
config = configparser.ConfigParser()
if options.inifile is not None and options.inifile != "":
    config.read(options.inifile)
    #   for section in config:
    #     print(section, file=sys.stderr)
    #     for item in config[section]:
    #        print(item, config[section][item], file=sys.stderr)

    configfiles = config['FILES']
    configoutput = config['OUTPUT']
    configperm = config['PERM']
    configmode = config['MODE']
    configini = config['INI']
    configprogram = config['PROGRAM']

    # print("After config1:",config['FILES']['path'], file=sys.stderr)

    # print("After config2:",configfiles['path'], file=sys.stderr)

    # set parameters based on inifile and options (options overrule the inifile)
    options.filename = setpar(options.filename, configfiles['file'])
    options.path = setpar(options.path, configfiles['path'])
    options.filelist = setpar(options.filelist, configfiles['filelist'])
    options.ext = setpar(options.ext, configfiles['ext'])
    options.tsv = setpar(options.tsv, configoutput.getboolean('tsv'))
    options.test = setpar(options.test, configfiles.getboolean('test'))
    options.outpath = setpar(options.outpath, configoutput['outpath'])
    options.outfile = setpar(options.outfile, configoutput['outfile'])
    options.permfile = setpar(options.permfile, configperm['permfile'])
    options.permfilepath = setpar(options.permfilepath, configperm['permfilepath'])
    options.verbose = setpar(options.verbose, configmode.getboolean('verbose'))
    options.inifile = setpar(options.inifile, configini['inifile'])
    options.reportevery = setpar(options.reportevery, configmode['reportevery'])

# print("After options:",options.path, file=sys.stderr)

defaultoutfilename = 'errors' + '_' + barenow

# set the defaults if no value from the options or configfile
options.filename = set_default(options.filename, "")
options.path = set_default(options.path, ".")
options.filelist = set_default(options.filelist, "")
options.ext = set_default(options.ext, ".xml")
options.tsv = set_default(options.tsv, False)
options.test = set_default(options.test, False)
options.outpath = set_default(options.outpath, ".")
options.outfile = set_default(options.outfile, defaultoutfilename)
options.permfile = set_default(options.permfile, "permannerrors")
options.permfilepath = set_default(options.permfilepath, "temp")
options.verbose = set_default(options.verbose, False)
(pbase, pext) = os.path.splitext(program_name)
options.inifile = set_default(options.inifile, pbase + ".ini")
options.reportevery = set_default(options.reportevery, "")

# print("After defaults:", options.path, file=sys.stderr)
username = os.environ.get('USERNAME')

if options.tsv:
    outfilename = options.outfile + "." + "txt"
else:
    outfilename = options.outfile + "." + "xlsx"

outfullname = os.path.join(options.outpath, outfilename)

if not os.path.exists(options.permfilepath):
    os.makedirs(options.permfilepath)

permfile = options.permfile + ".txt"
fullpermfile = os.path.join(options.permfilepath, permfile)

# read the comments from the existing file if any
# global error_annotations
error_annotations = dict()
# previousfullname = outfullname
previousfullname = 'errors.xlsx'
try:
    read_errors.read_errors(previousfullname, error_annotations, message)
except IOError:
    pass

# print("after reading the errors file:", file=sys.stderr)
# for el in error_annotations:
#  print(el, error_annotations[el], file =sys.stderr)  


# read additional ones from fullpermfile
# DONE

try:
    fpfile = open(fullpermfile, 'r', encoding='utf8')
    myreader = csv.reader(fpfile, delimiter=mysep, quotechar=myquotechar)
    fprowctr = -1
    for row in myreader:
        fprowctr += 1
        if fprowctr != 0:
            error_annotations[(row[2], row[3], row[4], row[5], row[6], row[7])] = (row[0], row[1], row[8])
    fpfile.close()
except FileNotFoundError:
    print("No permanent error annotations file found, new one will be created...", file=sys.stderr)

# print("after reading the perm file:", file=sys.stderr)
# for el in error_annotations:
#  print(el, error_annotations[el], file =sys.stderr)  


# write them all to the special file
# DONE

# lockfile = fullpermfile + ".lock"
# lock = filelock.FileLock(lockfile)

# try:
if True:
    #    with lock.acquire(timeout=20):
    if True:
        fpfile = open(fullpermfile, 'w', encoding='utf8')
        mywriter = csv.writer(fpfile, delimiter=mysep, quotechar=myquotechar, quoting=csv.QUOTE_MINIMAL,
                              lineterminator='\n')
        fpheader = ["User1", "User2", "File", "Mother", "Node", "ErrNr", "Arg1", "Arg2", "Annotator"]
        mywriter.writerow(fpheader)
        for (r2, r3, r4, r5, r6, r7) in error_annotations:
            (r0, r1, r10) = error_annotations[(r2, r3, r4, r5, r6, r7)]
            row = [r0, r1, r2, r3, r4, r5, r6, r7, r10]
            try:
                mywriter.writerow(row)
            except PermissionError as e:
                print('PermissionError')
                exit(-1)
        fpfile.close()
# except filelock.Timeout:
#    print("File {} is locked or not reachable. Please try again later.".format(fullpermfile))

# for el in error_annotations:
#  print(el, error_annotations[el], file =sys.stderr)  

if options.tsv:
    outfile = open(outfullname, "w", encoding="utf8")
    mywriter = csv.writer(outfile, delimiter="\t", quotechar='"', quoting=csv.QUOTE_MINIMAL, lineterminator='\n')
else:
    workbook = xlsxwriter.Workbook(outfullname, {"strings_to_numbers": True})
    worksheet = workbook.add_worksheet()

# flfile = open("errors.fl","w")
# print("Errors file list", file=flfile)

FL = FileLists()

basename = 'errors' + '_' + barenow
FL.assignname(basename)

global rowcounter
rowcounter = -1
header = ["User1", "User2", "Status", "File", "Mother", "Node", "ErrNr", "Arg1", "Message", "Arg2", "Remarks", "Path",
          "Annotator"]
creditrow = ["", "", message, "", "", "", "", "", credits, "", "", ""]
maxcol = len(header)

if options.tsv:
    mywriter.writerow(header)
    mywriter.writerow(creditrow)
else:
    rowcounter += 1
    worksheet.write_row(rowcounter, 0, header)
    rowcounter += 1
    worksheet.write_row(rowcounter, 0, creditrow)

# print("options.path=<{}>".format(options.path), file=sys.stderr)
if options.test:
    paths = ["./acetest"]
elif options.path != "" and options.filelist != "":
    paths = ["."]
elif options.path != "":
    paths = [options.path]
else:
    # paths= ["Jorik - AF", "Erlinde", "Remco - AF", "Sylvia", "0000"]
    paths = ["."]

# print("paths=<{}>".format(paths), file=sys.stderr)


for apath in paths:

    if options.filelist != "" and paths == ["."]:
        files = get_files(options.filelist)
    else:
        path = makeabs(apath)
        if options.filename != "":
            files = [options.filename]
        else:
            # files = [file for file in os.listdir(path) if getExt(file)==".xml"]
            files = []
            for root, dirs, thefiles in os.walk(path):
                for file in thefiles:
                    fullname = os.path.join(path, root, file)
                    (base, ext) = os.path.splitext(file)
                    if ext == options.ext: files.append(fullname)

    # print("files:")
    # for file in files: print(file)

    filectr = 0
    for filename in files:
        filectr += 1
        if options.reportevery != "":
            if (filectr % int(options.reportevery)) == 0:
                printq("{}\t".format(filectr, file=sys.stderr))
        fullname = os.path.join(path, filename)
        if options.verbose:
            print("Checking {}...".format(fullname))

        try:
            thefile = open(fullname, 'r', encoding='utf8')
        except FileNotFoundError:
            cp = CheckParameters(fullname, '', '', '', '', '', error_annotations)
            row = error_row(43, cp)
            printerror(row, options.tsv)
            continue
        except ET.ParseError:
            cp = CheckParameters(fullname, '', '', '', '', '', error_annotations)
            row = error_row(39, cp)
            printerror(row, options.tsv)
            continue
        except OSError as e:
            print('Error: OSError')
            workbook.close()
            exit(1)
        except:
            print('Error: Unknown error')
            workbook.close()
            exit(1)

        #      with open(fullname, 'r', encoding='utf8') as thefile:
        with thefile:
            try:
                tree = ET.parse(thefile)
            except ET.ParseError:
                tree = None
                cp = CheckParameters(fullname, '', '', '', '', '', error_annotations)
                row = error_row(39, cp)
                printerror(row, options.tsv)
            except UnicodeDecodeError:
                cp = CheckParameters(fullname, '', '', '', '', '', error_annotations)
                row = error_row(40, cp)
                printerror(row, options.tsv)
                windowsfile = open(fullname, 'r')
                try:
                    tree = ET.parse(windowsfile)
                except ValueError as e:
                    tree = None
                    cp = CheckParameters(fullname, '', '', '', '', str(e), error_annotations)
                    row = error_row(42, cp)
                    printerror(row, options.tsv)
                    # print('Error' + 'Char Decoding Error:' + file.name + ';' + str(e) , file=sys.stderr)
                except ET.ParseError:
                    tree = None
                    cp = CheckParameters(fullname, '', '', '', '', '', error_annotations)
                    row = error_row(39, cp)
                    printerror(row, options.tsv)
                else:
                    cp = CheckParameters(fullname, '', '', '', '', '', error_annotations)
                    row = error_row(41, cp)
                    printerror(row, options.tsv)
                    # print('File {} successfully parsed with Windows-1252 encoding'.format(fullname), file=sys.stderr)
            if tree is None:
                print("No tree found in {}".format(fullname), file=sys.stderr)
            else:
                toproot = tree.getroot()
                # the topnode is alpino_ds with node, sentence and comments as children
                root = toproot.find("node")
                if root is None:
                    print("No root found in {}".format(fullname), file=sys.stderr)
                else:
                    # first gather all indexed nodes and their attributes
                    indexednodes = {}
                    for node in root.iter():
                        if 'index' in node.attrib and ('pt' in node.attrib or 'cat' in node.attrib):
                            theindex = node.attrib['index']
                            indexednodes[theindex] = node
                    # print("indexednodes:")
                    # for i in indexednodes:
                    #   print(i, indexednodes[i])

                    # check whether there is an entry for each index
                    indexesOK = True
                    for node in root.iter():
                        if 'index' in node.attrib:
                            if node.attrib['index'] not in indexednodes:
                                errno = 32
                                indexesOK = False
                                arg1 = props2str(get_node_props(node))
                                arg2 = ""
                                motherrel = ""
                                mothercat = ""
                                remarks = ""
                                cp = CheckParameters(fullname, motherrel, mothercat, arg1, arg2, remarks,
                                                     error_annotations)
                                row = error_row(errno, cp)
                                printerror(row, options.tsv)

                    if indexesOK:
                        begins = []
                        ends = []
                        if basicchecks(root, None, fullname, begins, ends, error_annotations):
                            checks(root, None, fullname, error_annotations)
                            fulltreechecks(root, fullname, error_annotations)

if options.tsv:
    pass
else:
    worksheet.autofilter(0, 0, rowcounter, maxcol)
    worksheet.freeze_panes(1, 4)
    textwrap = workbook.add_format({'text_wrap': True})
    worksheet.set_column(0, 1, 13)
    worksheet.set_column(2, 2, 8)
    worksheet.set_column(3, 3, 48)
    worksheet.set_column(4, 7, 12)
    worksheet.set_column(8, 8, 30)
    worksheet.set_column(9, 9, 15)
    worksheet.set_column(10, 10, 20)

    try:
        workbook.close()
    except PermissionError:
        print("Please close the errors workbook and run again", file=sys.stderr)

# write the filelists
FL.print()

# write the configurationfile
config['PROGRAM'] = {}
config['PROGRAM']['name'] = program_name
config['PROGRAM']['version'] = version
config['FILES'] = {}
config['FILES']['file'] = options.filename
config['FILES']['path'] = options.path
config['FILES']['ext'] = options.ext
config['FILES']['test'] = str(options.test)

config['OUTPUT'] = {}
config['OUTPUT']['outpath'] = options.outpath
config['OUTPUT']['outfile'] = options.outfile
config['OUTPUT']['tsv'] = str(options.tsv)

config['PERM'] = {}
config['PERM']['permfile'] = options.permfile
config['PERM']['permfilepath'] = options.permfilepath

config['MODE'] = {}
config['MODE']['verbose'] = str(options.verbose)
config['MODE']['reportevery'] = options.reportevery

config['INI'] = {}
config['INI']['inifile'] = options.inifile

try:
    with open(options.inifile, 'w') as configfile:
        config.write(configfile)
except IOError:
    print("Error writing configuration file. No configuration file written", file=sys.stderr)
